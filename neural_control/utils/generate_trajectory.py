import argparse
import time

import casadi as cs
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from scipy import interpolate
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import ExpSineSquared

from neural_control.utils.q_funcs import (
    q_dot_q, quaternion_inverse, quaternion_to_euler
)
# from utils.visualization import debug_plot, draw_poly
"""
Autor: Elia Kaufmann
Script for generating random and geometric quadrotor trajectories
"""

from neural_control.environments.copter import copter_params


class Quad():

    def __init__(self, max_thrust_per_motor):
        '''

        :param mass: mass of the quadrotor in [kg]
        :param max_thrust_per_motor: maximum thrust in [N] per motor
        '''
        self.mass = copter_params["mass"]
        self.max_thrust_per_motor = max_thrust_per_motor

        self.J = np.array([.002, .002, .025])
        arm_length = copter_params["arm_length"]
        h = arm_length / np.sqrt(2.0)
        self.x_f = np.array([h, -h, -h, h])
        self.y_f = np.array([-h, -h, h, h])

        # For z thrust torque calculation
        self.c = 0.013  # m   (z torque generated by each motor)
        self.z_l_tau = np.array([-self.c, self.c, -self.c, self.c])


def check_trajectory(trajectory, inputs, tvec, plot=False):
    """
    @param trajectory:
    @param inputs:
    @param tvec:
    @param plot:
    @return:
    """

    print("Checking trajectory integrity...")

    dt = np.expand_dims(np.gradient(tvec, axis=0), axis=1)
    numeric_derivative = np.gradient(trajectory, axis=0) / dt

    errors = np.zeros((dt.shape[0], 3))

    num_bodyrates = []

    for i in range(dt.shape[0]):
        # 1) check if velocity is consistent with position
        numeric_velocity = numeric_derivative[i, 0:3]
        analytic_velocity = trajectory[i, 7:10]
        errors[i, 0] = np.linalg.norm(numeric_velocity - analytic_velocity)
        if not np.allclose(
            analytic_velocity, numeric_velocity, atol=0.05, rtol=0.05
        ):
            print("inconsistent linear velocity at i = %d" % i)
            print(numeric_velocity)
            print(analytic_velocity)
            return False

        # 2) check if attitude is consistent with acceleration
        gravity = 9.81
        numeric_thrust = numeric_derivative[i, 7:10] + np.array(
            [0.0, 0.0, gravity]
        )
        numeric_thrust = numeric_thrust / np.linalg.norm(numeric_thrust)
        analytic_attitude = trajectory[i, 3:7]
        if np.abs(np.linalg.norm(analytic_attitude) - 1.0) > 1e-6:
            print("quaternion does not have unit norm at i = %d" % i)
            print(analytic_attitude)
            print(np.linalg.norm(analytic_attitude))
            return False

        e_z = np.array([0.0, 0.0, 1.0])
        q_w = 1.0 + np.dot(e_z, numeric_thrust)
        q_xyz = np.cross(e_z, numeric_thrust)
        numeric_attitude = 0.5 * np.array([q_w] + q_xyz.tolist())
        numeric_attitude = numeric_attitude / np.linalg.norm(numeric_attitude)
        # the two attitudes can only differ in yaw --> check x,y component
        q_diff = q_dot_q(
            quaternion_inverse(analytic_attitude), numeric_attitude
        )
        errors[i, 1] = np.linalg.norm(q_diff[1:3])
        if not np.allclose(q_diff[1:3], np.zeros(2, ), atol=0.05, rtol=0.05):
            print("Attitude and acceleration do not match at i = %d" % i)
            print(analytic_attitude)
            print(numeric_attitude)
            print(q_diff)
            return False

        # 3) check if bodyrates agree with attitude difference
        numeric_bodyrates = 2.0 * q_dot_q(
            quaternion_inverse(trajectory[i, 3:7]), numeric_derivative[i, 3:7]
        )[1:]
        num_bodyrates.append(numeric_bodyrates)
        analytic_bodyrates = trajectory[i, 10:13]
        errors[i, 2] = np.linalg.norm(numeric_bodyrates - analytic_bodyrates)
        if not np.allclose(
            numeric_bodyrates, analytic_bodyrates, atol=0.05, rtol=0.05
        ):
            print("inconsistent angular velocity at i = %d" % i)
            print(numeric_bodyrates)
            print(analytic_bodyrates)
            return False

    print("Trajectory check successful")
    print("Maximum linear velocity error: %.5f" % np.max(errors[:, 0]))
    print("Maximum attitude error: %.5f" % np.max(errors[:, 1]))
    print("Maximum angular velocity error: %.5f" % np.max(errors[:, 2]))

    if plot:
        num_bodyrates = np.stack(num_bodyrates)
        plt.figure()
        for i in range(3):
            plt.subplot(3, 2, i * 2 + 1)
            plt.plot(numeric_derivative[:, i], label='numeric')
            plt.plot(trajectory[:, 7 + i], label='analytic')
            plt.ylabel('m/s')
            if i == 0:
                plt.title("Velocity check")
            plt.legend()

        for i in range(3):
            plt.subplot(3, 2, i * 2 + 2)
            plt.plot(num_bodyrates[:, i], label='numeric')
            plt.plot(trajectory[:, 10 + i], label='analytic')
            plt.ylabel('rad/s')
            if i == 0:
                plt.title("Body rate check")
            plt.legend()
        plt.suptitle('Integrity check of reference trajectory')
        plt.show()

    return True


def smooth(x, window_len=11, window='hanning'):
    """smooth the data using a window with requested size.

    This method is based on the convolution of a scaled window with the signal.
    The signal is prepared by introducing reflected copies of the signal
    (with the window size) in both ends so that transient parts are minimized
    in the begining and end part of the output signal.

    input:
        x: the input signal
        window_len: the dimension of the smoothing window; should be an odd int
        window: the type of window from 'flat', 'hanning', 'hamming',
            'bartlett', 'blackman'
            flat window will produce a moving average smoothing.

    output:
        the smoothed signal

    example:

    t=linspace(-2,2,0.1)
    x=sin(t)+randn(len(t))*0.1
    y=smooth(x)

    see also:

    numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman,
    numpy.convolve
    scipy.signal.lfilter

    TODO: the window parameter could be the window itself if an array
    instead of a string
    NOTE: length(output) != length(input), to correct this: return y
    [(window_len/2-1):-(window_len/2)] instead of just y.
    """

    if x.ndim != 1:
        raise ValueError("smooth only accepts 1 dimension arrays.")

    if x.size < window_len:
        raise ValueError("Input vector needs to be bigger than window size.")

    if window_len < 3:
        return x

    if not window in ['flat', 'hanning', 'hamming', 'bartlett', 'blackman']:
        raise ValueError(
            "Window is on of 'flat', 'hanning', 'hamming', 'bartlett','blackman'"
        )

    # s = np.r_[x[(window_len - 1) // 2:0:-1], x, x[-2:-(window_len - 1) // 2:-1]]

    x_start = np.repeat(x[0], (window_len - 1) // 2)
    x_end = np.repeat(x[-1], (window_len - 1) // 2)
    s = np.concatenate([x_start, x, x_end])

    if window == 'flat':  # moving average
        w = np.ones(window_len, 'd')
    else:
        w = eval('np.' + window + '(window_len)')

    y = np.convolve(w / w.sum(), s, mode='valid')
    return y


def compute_full_traj(quad, t_np, pos_np, vel_np, alin_np):
    len_traj = t_np.shape[0]
    dt = np.mean(np.diff(t_np))

    # Add gravity to accelerations
    gravity = 9.81
    thrust_np = alin_np + np.tile(
        np.array([[0, 0, 1]]), (len_traj, 1)
    ) * gravity
    # Compute body axes
    z_b = thrust_np / np.sqrt(np.sum(thrust_np**2, 1))[:, np.newaxis]
    # new way to compute attitude:
    # https://math.stackexchange.com/questions/2251214/calculate-quaternions-from-two-directional-vectors
    e_z = np.array([[0.0, 0.0, 1.0]])
    q_w = 1.0 + np.sum(e_z * z_b, axis=1)
    q_xyz = np.cross(e_z, z_b)
    att_np = 0.5 * np.concatenate([np.expand_dims(q_w, axis=1), q_xyz], axis=1)
    att_np = att_np / np.sqrt(np.sum(att_np**2, 1))[:, np.newaxis]

    rate_np = np.zeros_like(pos_np)
    f_t = np.zeros((len_traj, 1))

    # Use numerical differentiation of quaternions
    q_dot = np.gradient(att_np, axis=0) / dt
    w_int = np.zeros((len_traj, 3))
    for i in range(len_traj):
        w_int[
            i, :] = 2.0 * q_dot_q(quaternion_inverse(att_np[i, :]),
                                  q_dot[i])[1:]
        f_t[i, 0] = quad.mass * z_b[i].dot(thrust_np[i, :].T)
    rate_np[:, 0] = w_int[:, 0]
    rate_np[:, 1] = w_int[:, 1]
    rate_np[:, 2] = w_int[:, 2]

    minimize_yaw_rate = True
    n_iter_yaw_fix = 20
    if minimize_yaw_rate:
        for iter_yaw_fix in range(n_iter_yaw_fix):
            # print(
            #     "Maximum yawrate before adaption %d / %d: %.6f" %
            #     (iter_yaw_fix, n_iter_yaw_fix, np.max(np.abs(rate_np[:, 2])))
            # )
            q_new = att_np
            yaw_corr_acc = 0.0
            for i in range(1, len_traj):
                yaw_corr = -rate_np[i, 2] * dt
                yaw_corr_acc += yaw_corr
                q_corr = np.array(
                    [
                        np.cos(yaw_corr_acc / 2.0), 0.0, 0.0,
                        np.sin(yaw_corr_acc / 2.0)
                    ]
                )
                q_new[i, :] = q_dot_q(att_np[i, :], q_corr)
                w_int[i, :] = 2.0 * q_dot_q(
                    quaternion_inverse(att_np[i, :]), q_dot[i]
                )[1:]

            q_new_dot = np.gradient(q_new, axis=0) / dt
            for i in range(1, len_traj):
                w_int[i, :] = 2.0 * q_dot_q(
                    quaternion_inverse(q_new[i, :]), q_new_dot[i]
                )[1:]

            att_np = q_new
            rate_np[:, 0] = w_int[:, 0]
            rate_np[:, 1] = w_int[:, 1]
            rate_np[:, 2] = w_int[:, 2]
            # print(
            #     "Maximum yawrate after adaption: %.3f" %
            #     np.max(np.abs(rate_np[:, 2]))
            # )
            if np.max(np.abs(rate_np[:, 2])) < 0.005:
                break

    arot_np = np.gradient(rate_np, axis=0)
    trajectory = np.concatenate(
        [pos_np, att_np, vel_np, rate_np, alin_np, arot_np], axis=1
    )
    motor_inputs = np.zeros((pos_np.shape[0], 4))

    # Compute inputs
    rate_dot = np.gradient(rate_np, axis=0) / dt
    rate_x_Jrate = np.array(
        [
            (quad.J[2] - quad.J[1]) * rate_np[:, 2] * rate_np[:, 1],
            (quad.J[0] - quad.J[2]) * rate_np[:, 0] * rate_np[:, 2],
            (quad.J[1] - quad.J[0]) * rate_np[:, 1] * rate_np[:, 0]
        ]
    ).T

    tau = rate_dot * quad.J[np.newaxis, :] + rate_x_Jrate
    b = np.concatenate((tau, f_t), axis=-1)
    a_mat = np.concatenate(
        (
            quad.y_f[np.newaxis, :], -quad.x_f[np.newaxis, :],
            quad.z_l_tau[np.newaxis, :], np.ones_like(quad.z_l_tau
                                                      )[np.newaxis, :]
        ), 0
    )

    for i in range(len_traj):
        motor_inputs[i, :] = np.linalg.solve(a_mat, b[i, :])

    return trajectory, motor_inputs, t_np


def compute_random_trajectory(
    quad,
    arena_bound_max,
    arena_bound_min,
    freq_x,
    freq_y,
    freq_z,
    duration=30.0,
    dt=0.01
):
    # print("Computing random trajectory!")
    assert dt == 0.01

    debug = False
    seed = None  # 20
    if seed is None:
        seed = np.random.randint(0, 9999)

    # kernel to map functions that repeat exactly
    # print("seed is: %d" % seed)
    kernel_y = ExpSineSquared(length_scale=freq_x, periodicity=17) \
               + ExpSineSquared(length_scale=3.0, periodicity=23) \
               + ExpSineSquared(length_scale=4.0, periodicity=51)
    kernel_x = ExpSineSquared(length_scale=freq_y, periodicity=37) \
               + ExpSineSquared(length_scale=3.0, periodicity=61) \
               + ExpSineSquared(length_scale=4.0, periodicity=13)
    kernel_z = ExpSineSquared(length_scale=freq_z, periodicity=19) \
               + ExpSineSquared(length_scale=3.0, periodicity=29) \
               + ExpSineSquared(length_scale=4.0, periodicity=53)

    gp_x = GaussianProcessRegressor(kernel=kernel_x)
    gp_y = GaussianProcessRegressor(kernel=kernel_y)
    gp_z = GaussianProcessRegressor(kernel=kernel_z)

    t_coarse = np.linspace(0.0, duration, int(duration / 0.1), endpoint=False)
    t_vec, dt = np.linspace(
        0.0, duration, int(duration / dt), endpoint=False, retstep=True
    )

    t = cs.MX.sym("t")
    # t_speed is a function starting at zero and ending at zero that
    # modulates time
    # casadi cannot do symbolic integration --> write down the integrand by
    # hand of 2.0*sin^2(t)
    # t_adj = 2.0 * (t / 2.0 - cs.sin(2.0 / duration * cs.pi * t) /
    # (4.0 * cs.pi / duration))
    tau = t / duration
    t_adj = 1.524 * duration * (
        -(
            8 * cs.cos(tau * cs.pi) * cs.constpow(cs.sin(tau * cs.pi), 5) +
            10 * cs.cos(tau * cs.pi) * cs.constpow(cs.sin(tau * cs.pi), 3) +
            39 * cs.sin(tau * cs.pi) * cs.cos(tau * cs.pi) +
            12 * cs.sin(2 * tau * cs.pi) * cs.cos(2 * tau * cs.pi) -
            63 * tau * cs.pi
        ) / (96 * cs.pi)
    )

    f_t_adj = cs.Function('t_adj', [t], [t_adj])
    scaled_time = f_t_adj(t_vec)

    # print("sampling x...")
    x_sample_hr = gp_x.sample_y(t_coarse[:, np.newaxis], 1, random_state=seed)
    # print("sampling y...")
    y_sample_hr = gp_y.sample_y(
        t_coarse[:, np.newaxis], 1, random_state=seed + 1
    )
    # print("sampling z...")
    z_sample_hr = gp_z.sample_y(
        t_coarse[:, np.newaxis], 1, random_state=seed + 2
    )

    pos_np = np.concatenate([x_sample_hr, y_sample_hr, z_sample_hr], axis=1)
    # scale to arena bounds
    max_traj = np.max(pos_np, axis=0)
    min_traj = np.min(pos_np, axis=0)
    pos_centered = pos_np - (max_traj + min_traj) / 2.0
    pos_scaled = pos_centered * (arena_bound_max -
                                 arena_bound_min) / (max_traj - min_traj)
    pos_arena = pos_scaled + (arena_bound_max + arena_bound_min) / 2.0

    if debug:
        plt.plot(pos_arena[:, 0], label="x")
        plt.plot(pos_arena[:, 1], label="y")
        plt.plot(pos_arena[:, 2], label="z")
        plt.legend()
        plt.show()

    # rescale time to get smooth start and end states
    pos_blub_x = interpolate.interp1d(
        t_coarse, pos_arena[:, 0], kind="cubic", fill_value="extrapolate"
    )
    pos_blub_y = interpolate.interp1d(
        t_coarse, pos_arena[:, 1], kind="cubic", fill_value="extrapolate"
    )
    pos_blub_z = interpolate.interp1d(
        t_coarse, pos_arena[:, 2], kind="cubic", fill_value="extrapolate"
    )
    pos_arena = np.concatenate(
        [
            pos_blub_x(scaled_time),
            pos_blub_y(scaled_time),
            pos_blub_z(scaled_time)
        ],
        axis=1
    )

    pos_arena = np.concatenate(
        [
            smooth(np.squeeze(pos_arena[:, 0]), window_len=11)[:, np.newaxis],
            smooth(np.squeeze(pos_arena[:, 1]), window_len=11)[:, np.newaxis],
            smooth(np.squeeze(pos_arena[:, 2]), window_len=11)[:, np.newaxis]
        ],
        axis=1
    )

    # compute numeric derivative & smooth things
    vel_arena = np.gradient(pos_arena, axis=0) / dt
    vel_arena = np.concatenate(
        [
            smooth(np.squeeze(vel_arena[:, 0]), window_len=11)[:, np.newaxis],
            smooth(np.squeeze(vel_arena[:, 1]), window_len=11)[:, np.newaxis],
            smooth(np.squeeze(vel_arena[:, 2]), window_len=11)[:, np.newaxis]
        ],
        axis=1
    )
    acc_arena = np.gradient(vel_arena, axis=0) / dt
    acc_arena = np.concatenate(
        [
            smooth(np.squeeze(acc_arena[:, 0]), window_len=11)[:, np.newaxis],
            smooth(np.squeeze(acc_arena[:, 1]), window_len=11)[:, np.newaxis],
            smooth(np.squeeze(acc_arena[:, 2]), window_len=11)[:, np.newaxis]
        ],
        axis=1
    )
    t_np = t_vec

    trajectory, motor_inputs, t_vec = compute_full_traj(
        quad, t_np, pos_arena, vel_arena, acc_arena
    )

    return trajectory, motor_inputs, t_vec


def compute_geometric_trajectory(quad, duration=30.0, dt=0.001):
    print("Computing geometric trajectory!")
    assert dt == 0.001

    debug = False

    # define position trajectory symbolically
    t = cs.MX.sym("t")
    # t_speed is a function starting at zero and ending at zero that
    # modulates time
    # casadi cannot do symbolic integration --> write down the integrand by
    # hand of 2.0*sin^2(t)
    # t_adj = 2.0 * (t / 2.0 - cs.sin(2.0 / duration * cs.pi * t) /
    # (4.0 * cs.pi / duration))
    tau = t / duration
    t_adj = 1.524 * duration * (
        -(
            8 * cs.cos(tau * cs.pi) * cs.constpow(cs.sin(tau * cs.pi), 5) +
            10 * cs.cos(tau * cs.pi) * cs.constpow(cs.sin(tau * cs.pi), 3) +
            39 * cs.sin(tau * cs.pi) * cs.cos(tau * cs.pi) +
            12 * cs.sin(2 * tau * cs.pi) * cs.cos(2 * tau * cs.pi) -
            63 * tau * cs.pi
        ) / (96 * cs.pi)
    )

    # sphere trajectory rotating around x-axis
    radius_x = 5.0
    radius_y = 3.5
    radius_z = 2.5

    # fast config
    # freq_slow = 0.009
    # freq_fast = 0.33
    # slow config
    freq_slow = 0.02
    freq_fast = 0.12
    pos_x = 3.0 + radius_x * (
        cs.sin(2.0 * cs.pi * freq_fast * t_adj) *
        cs.cos(2.0 * cs.pi * freq_slow * t_adj)
    )
    pos_y = 1.0 + radius_y * (cs.cos(2.0 * cs.pi * freq_fast * t_adj))
    pos_z = 3.5 + radius_z * (
        cs.sin(2.0 * cs.pi * freq_fast * t_adj) *
        cs.sin(2.0 * cs.pi * freq_slow * t_adj)
    )

    # TODO: define yaw trajectory
    pos = cs.vertcat(pos_x, pos_y, pos_z)
    vel = cs.jacobian(pos, t)
    acc = cs.jacobian(vel, t)
    jerk = cs.jacobian(acc, t)
    snap = cs.jacobian(jerk, t)

    t_vec, dt = np.linspace(
        0.0, duration, int(duration / dt), endpoint=False, retstep=True
    )

    f_t_adj = cs.Function('t_adj', [t], [t_adj])
    f_pos = cs.Function('f_pos', [t], [pos])
    f_vel = cs.Function('f_vel', [t], [vel])
    f_acc = cs.Function('f_acc', [t], [acc])
    f_jerk = cs.Function('f_jerk', [t], [jerk])
    f_snap = cs.Function('f_snap', [t], [snap])

    # evaluation seems to only work for scalar inputs --> iterate over time vector
    pos_list = []
    vel_list = []
    alin_list = []
    t_adj_list = []
    for t_curr in t_vec:
        t_adj_list.append(f_t_adj(t_curr).full().squeeze())
        pos_list.append(f_pos(t_curr).full().squeeze())
        vel_list.append(f_vel(t_curr).full().squeeze())
        alin_list.append(f_acc(t_curr).full().squeeze())

    t_adj_np = np.array(t_adj_list)
    pos_np = np.array(pos_list)
    vel_np = np.array(vel_list)
    alin_np = np.array(alin_list)

    if debug:
        plt.plot(t_adj_np)
        plt.show()

    trajectory, motor_inputs, t_vec = compute_full_traj(
        quad, t_vec, pos_np, vel_np, alin_np
    )

    return trajectory, motor_inputs, t_vec


def generate_trajectory(
    duration, dt, mode="random", freq_x=2, freq_y=2, freq_z=2
):
    quad = Quad(10.0)

    # the arena bounds
    arena_bound_max = np.array([6.5, 10, 10])  # np.array([8.0, 5.0, 5.0]) #
    arena_bound_min = np.array([-6.5, -10, 0])

    # compute trajector
    trajectory, motor_inputs, t_vec = compute_random_trajectory(
        quad, arena_bound_max, arena_bound_min, freq_x, freq_y, freq_z,
        duration, 0.01
    )
    # dt for trajectory generation is 0.01, then transform back
    take_every_nth = int(dt / 0.01)
    taken_every = trajectory[::take_every_nth, :]
    # transform to euler angels
    quaternions = taken_every[:, 3:7]
    euler_angles = np.array([quaternion_to_euler(q) for q in quaternions])
    # stack position, euler angles, velocity, body rates
    # print(
    #     taken_every[:, :3].shape, euler_angles.shape,
    #     taken_every[:, 7:10].shape, taken_every[:, 16:19].shape
    # )
    transformed_ref = np.hstack(
        (
            taken_every[:, :3], euler_angles, taken_every[:, 7:10],
            taken_every[:, 16:19]
        )
    )
    # print("transformed shape", transformed_ref.shape)
    return transformed_ref


if __name__ == '__main__':
    # parser = argparse.ArgumentParser(
    #     description='Generate a quadrotor trajectory.'
    # )
    # parser.add_argument(
    #     '--traj_type', help='Trajectory type to generate', required=True
    # )

    # args = parser.parse_args()
    # traj_type = args.traj_type
    traj_type = "random"

    start_time = time.time()
    quad = Quad(10.0)
    debug = False
    dt_final = 0.05

    # the arena bounds, at the moment only used by the random trajectory
    # generator
    arena_bound_max = np.array([10, 10, 10])  # np.array([8.0, 5.0, 5.0]) #
    arena_bound_min = np.array([0, 0, 0])  # np.array([-4.0, -4.0, 1.0]) #

    ############################################
    if traj_type == 'geometric':
        # geometric trajectory settings
        dt = 0.001
        duration = 60.0
        output_fn = "satellite_trajectory.csv"
        trajectory, motor_inputs, t_vec = compute_geometric_trajectory(
            quad, duration, dt
        )
    ############################################
    elif traj_type == 'random':
        ############################################
        # random trajectory settings
        freq_x = 2  # 0.29
        freq_y = 2  # 0.27
        freq_z = 2  # 0.7
        dt = 0.01
        duration = 10.0
        output_fn = "random_trajectory.csv"
        trajectory, motor_inputs, t_vec = compute_random_trajectory(
            quad, arena_bound_max, arena_bound_min, freq_x, freq_y, freq_z,
            duration, dt
        )
    else:
        print("Unknown trajectory type.")
        exit()
    ############################################

    # prepare with euler angles etc for my purposes:
    take_every_nth = int(dt_final / 0.01)
    print("trajectory shape", trajectory.shape)
    taken_every = trajectory[::take_every_nth, :]
    quaternions = taken_every[:, 3:7]
    euler_angles = np.array([quaternion_to_euler(q) for q in quaternions])
    print("euler angles shape", euler_angles.shape)
    # stack position, euler angles, velocity, body rates
    print(
        taken_every[:, :3].shape, euler_angles.shape,
        taken_every[:, 7:10].shape, taken_every[:, 16:19].shape
    )
    transformed_ref = np.hstack(
        (
            taken_every[:, :3], euler_angles, taken_every[:, 7:10],
            taken_every[:, 16:19]
        )
    )
    print("transformed shape", transformed_ref.shape)
    print(np.max(np.absolute(transformed_ref[:, 6:9])))

    if False:  # check_trajectory(trajectory, motor_inputs, t_vec, False):
        # if debug:
        #     debug_plot(trajectory, motor_inputs, t_vec)
        # draw_poly(trajectory[:, :13], motor_inputs, t_vec)

        # the saved trajectory is sampled at 100Hz
        # save trajectory to csv
        df_traj = pd.DataFrame()
        df_traj['t'] = t_vec[::take_every_nth]
        df_traj['p_x'] = trajectory[::take_every_nth, 0]
        df_traj['p_y'] = trajectory[::take_every_nth, 1]
        df_traj['p_z'] = trajectory[::take_every_nth, 2]

        df_traj['q_w'] = trajectory[::take_every_nth, 3]
        df_traj['q_x'] = trajectory[::take_every_nth, 4]
        df_traj['q_y'] = trajectory[::take_every_nth, 5]
        df_traj['q_z'] = trajectory[::take_every_nth, 6]

        df_traj['v_x'] = trajectory[::take_every_nth, 7]
        df_traj['v_y'] = trajectory[::take_every_nth, 8]
        df_traj['v_z'] = trajectory[::take_every_nth, 9]

        df_traj['w_x'] = trajectory[::take_every_nth, 10]
        df_traj['w_y'] = trajectory[::take_every_nth, 11]
        df_traj['w_z'] = trajectory[::take_every_nth, 12]

        df_traj['a_lin_x'] = trajectory[::take_every_nth, 13]
        df_traj['a_lin_y'] = trajectory[::take_every_nth, 14]
        df_traj['a_lin_z'] = trajectory[::take_every_nth, 15]

        df_traj['a_rot_x'] = trajectory[::take_every_nth, 16]
        df_traj['a_rot_y'] = trajectory[::take_every_nth, 17]
        df_traj['a_rot_z'] = trajectory[::take_every_nth, 18]

        df_traj['u_1'] = motor_inputs[::take_every_nth,
                                      0] / quad.max_thrust_per_motor
        df_traj['u_2'] = motor_inputs[::take_every_nth,
                                      1] / quad.max_thrust_per_motor
        df_traj['u_3'] = motor_inputs[::take_every_nth,
                                      2] / quad.max_thrust_per_motor
        df_traj['u_4'] = motor_inputs[::take_every_nth,
                                      3] / quad.max_thrust_per_motor

        print("Saving trajectory to [%s]." % output_fn)
        df_traj.to_csv(output_fn, index=False)
    print(
        "Trajectory generation took [%.3f] seconds." %
        (time.time() - start_time)
    )
